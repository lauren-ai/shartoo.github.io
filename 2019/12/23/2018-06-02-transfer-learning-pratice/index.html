<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8" >
    <meta name="baidu-site-verification" content="dIcXMeY8Ya" />
    
    <title>迁移学习实践-Tensorflow分类任务 | Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" >
    <meta name="keywords" content="Jelon, 前端, Web, 张德龙, 前端开发" >
    <meta name="description" content="Jelon个人前端小站" >

    
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml" >
    
    
    <link rel="shortcut icon" href="/favicon.ico" >
    
    
<link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]>
    
<script src="/js/html5.js"></script>

    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


<meta name="generator" content="Hexo 4.2.0"></head>

<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/" target="_blank" rel="noopener">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">Hexo</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/2019/12/23/2018-06-02-transfer-learning-pratice/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/2019/12/23/2018-06-02-transfer-learning-pratice/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/2019/12/23/2018-06-02-transfer-learning-pratice/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/2019/12/23/2018-06-02-transfer-learning-pratice/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/jangdelong" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                        <a href="http://weibo.com/jangdelong" class="sinaweibo" target="_blank"><b>■</b> 新浪微博</a>
                    
                        <a href="https://www.facebook.com/profile.php?id=100011855760219&amp;ref=bookmarks" class="qqweibo" target="_blank"><b>■</b> Facebook</a>
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon" >
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章页 -->
<!-- 文章 -->
<article class="post article">
    <header class="text-center">
        <h3 class="post-title"><span>迁移学习实践-Tensorflow分类任务</span></h3>
    </header>
    <p class="post-meta text-center">
        Jelon 发表于
        <time datetime="2019-12-23T10:45:59.605Z">2019-12-23</time>
    </p>
    <div class="post-content">
        <p>摘自 : <a href="https://towardsdatascience.com/a-comprehensive-hands-on-guide-to-transfer-learning-with-real-world-applications-in-deep-learning-212bf3b2f27a" target="_blank" rel="noopener">medium transfer learning</a></p>
<h2 id="1-说明和准备"><a href="#1-说明和准备" class="headerlink" title="1 说明和准备"></a>1 说明和准备</h2><h3 id="1-1-任务问题"><a href="#1-1-任务问题" class="headerlink" title="1.1 任务问题"></a>1.1 任务问题</h3><p>我们要对只有4000张图片(3000张训练，1000张验证)的数据集做图像分类，分为<code>猫</code>和<code>狗</code>两类。图片数据可以从<a href="https://www.kaggle.com/c/dogs-vs-cats/data" target="_blank" rel="noopener">kaggle 猫狗分类挑战</a>上下载到25000张，不过为了演示迁移学习，假定只有4000张图片。</p>
<h3 id="1-2-数据准备"><a href="#1-2-数据准备" class="headerlink" title="1.2 数据准备"></a>1.2 数据准备</h3><p>首先下载全部的数据集，然后筛选出其中的4000张。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import glob</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line">import shutil</span><br><span class="line">np.random.seed(42)</span><br><span class="line">files &#x3D; glob.glob(&#39;train&#x2F;*&#39;)</span><br><span class="line"># 载入全部的猫狗图片</span><br><span class="line">cat_files &#x3D; [fn for fn in files if &#39;cat&#39; in fn]</span><br><span class="line">dog_files &#x3D; [fn for fn in files if &#39;dog&#39; in fn]</span><br><span class="line">print(len(cat_files), len(dog_files))</span><br><span class="line"># (12500, 12500)</span><br><span class="line"></span><br><span class="line"># 筛选出其中的4000张图片</span><br><span class="line">cat_train &#x3D; np.random.choice(cat_files, size&#x3D;1500, replace&#x3D;False)</span><br><span class="line">dog_train &#x3D; np.random.choice(dog_files, size&#x3D;1500, replace&#x3D;False)</span><br><span class="line">cat_files &#x3D; list(set(cat_files) - set(cat_train))</span><br><span class="line">dog_files &#x3D; list(set(dog_files) - set(dog_train))</span><br><span class="line"></span><br><span class="line">cat_val &#x3D; np.random.choice(cat_files, size&#x3D;500, replace&#x3D;False)</span><br><span class="line">dog_val &#x3D; np.random.choice(dog_files, size&#x3D;500, replace&#x3D;False)</span><br><span class="line">cat_files &#x3D; list(set(cat_files) - set(cat_val))</span><br><span class="line">dog_files &#x3D; list(set(dog_files) - set(dog_val))</span><br><span class="line"></span><br><span class="line">cat_test &#x3D; np.random.choice(cat_files, size&#x3D;500, replace&#x3D;False)</span><br><span class="line">dog_test &#x3D; np.random.choice(dog_files, size&#x3D;500, replace&#x3D;False)</span><br><span class="line"></span><br><span class="line">print(&#39;Cat datasets:&#39;, cat_train.shape, cat_val.shape, cat_test.shape)</span><br><span class="line">print(&#39;Dog datasets:&#39;, dog_train.shape, dog_val.shape, dog_test.shape)</span><br><span class="line"># Cat datasets: (1500,) (500,) (500,)</span><br><span class="line"># Dog datasets: (1500,) (500,) (500,)</span><br></pre></td></tr></table></figure>
<p>将数据子集单独放到其他文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">train_dir &#x3D; &#39;training_data&#39;</span><br><span class="line">val_dir &#x3D; &#39;validation_data&#39;</span><br><span class="line">test_dir &#x3D; &#39;test_data&#39;</span><br><span class="line"></span><br><span class="line">train_files &#x3D; np.concatenate([cat_train, dog_train])</span><br><span class="line">validate_files &#x3D; np.concatenate([cat_val, dog_val])</span><br><span class="line">test_files &#x3D; np.concatenate([cat_test, dog_test])</span><br><span class="line"></span><br><span class="line">os.mkdir(train_dir) if not os.path.isdir(train_dir) else None</span><br><span class="line">os.mkdir(val_dir) if not os.path.isdir(val_dir) else None</span><br><span class="line">os.mkdir(test_dir) if not os.path.isdir(test_dir) else None</span><br><span class="line"></span><br><span class="line">for fn in train_files:</span><br><span class="line">    shutil.copy(fn, train_dir)</span><br><span class="line"></span><br><span class="line">for fn in validate_files:</span><br><span class="line">    shutil.copy(fn, val_dir)</span><br><span class="line">    </span><br><span class="line">for fn in test_files:</span><br><span class="line">    shutil.copy(fn, test_dir)</span><br></pre></td></tr></table></figure>

<p>为模型准备数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import glob</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from keras.preprocessing.image import ImageDataGenerator, load_img, img_to_array, array_to_img</span><br><span class="line"></span><br><span class="line">IMG_DIM &#x3D; (150, 150)</span><br><span class="line"></span><br><span class="line">train_files &#x3D; glob.glob(&#39;training_data&#x2F;*&#39;)</span><br><span class="line">train_imgs &#x3D; [img_to_array(load_img(img, target_size&#x3D;IMG_DIM)) for img in train_files]</span><br><span class="line">train_imgs &#x3D; np.array(train_imgs)</span><br><span class="line">train_labels &#x3D; [fn.split(&#39;\\&#39;)[1].split(&#39;.&#39;)[0].strip() for fn in train_files]</span><br><span class="line"></span><br><span class="line">validation_files &#x3D; glob.glob(&#39;validation_data&#x2F;*&#39;)</span><br><span class="line">validation_imgs &#x3D; [img_to_array(load_img(img, target_size&#x3D;IMG_DIM)) for img in validation_files]</span><br><span class="line">validation_imgs &#x3D; np.array(validation_imgs)</span><br><span class="line">validation_labels &#x3D; [fn.split(&#39;\\&#39;)[1].split(&#39;.&#39;)[0].strip() for fn in validation_files]</span><br><span class="line"></span><br><span class="line">print(&#39;Train dataset shape:&#39;, train_imgs.shape, </span><br><span class="line">      &#39;\tValidation dataset shape:&#39;, validation_imgs.shape)</span><br><span class="line"># Train dataset shape: (3000, 150, 150, 3)  </span><br><span class="line"># Validation dataset shape: (1000, 150, 150, 3)</span><br></pre></td></tr></table></figure>
<p>现在，我们得到了3000张训练集和1000张验证集，图像长宽为$150\times 150$，接下来，我们要将图片像素矩阵值取值范围缩放到0到1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">train_imgs_scaled &#x3D; train_imgs.astype(&#39;float32&#39;)</span><br><span class="line">validation_imgs_scaled &#x3D; validation_imgs.astype(&#39;float32&#39;)</span><br><span class="line">train_imgs_scaled &#x2F;&#x3D; 255</span><br><span class="line">validation_imgs_scaled &#x2F;&#x3D; 255</span><br><span class="line"></span><br><span class="line">print(train_imgs[0].shape)</span><br><span class="line">array_to_img(train_imgs[0])</span><br></pre></td></tr></table></figure>

<p>一些基本参数，同时将字符型的分类类别改为数值型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input_shape &#x3D; (150, 150, 3)</span><br><span class="line"></span><br><span class="line"># encode text category labels</span><br><span class="line">from sklearn.preprocessing import LabelEncoder</span><br><span class="line"></span><br><span class="line">le &#x3D; LabelEncoder()</span><br><span class="line">le.fit(train_labels)</span><br><span class="line">train_labels_enc &#x3D; le.transform(train_labels)</span><br><span class="line">validation_labels_enc &#x3D; le.transform(validation_labels)</span><br><span class="line"></span><br><span class="line">print(train_labels[1495:1505], train_labels_enc[1495:1505])</span><br><span class="line"># [&#39;cat&#39;, &#39;cat&#39;, &#39;cat&#39;, &#39;cat&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;dog&#39;, &#39;dog&#39;, &#39;dog&#39;, &#39;dog&#39;] [0 0 0 0 0 1 1 1 1 1]</span><br></pre></td></tr></table></figure>

<h2 id="2-基准模型"><a href="#2-基准模型" class="headerlink" title="2 基准模型"></a>2 基准模型</h2><p>先手写个基准的CNN模型，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout</span><br><span class="line">from keras.models import Sequential</span><br><span class="line">from keras import optimizers</span><br><span class="line"></span><br><span class="line">model &#x3D; Sequential()</span><br><span class="line">model.add(Conv2D(16, kernel_size&#x3D;(3, 3), activation&#x3D;&#39;relu&#39;, </span><br><span class="line">                 input_shape&#x3D;input_shape))</span><br><span class="line">model.add(MaxPooling2D(pool_size&#x3D;(2, 2)))</span><br><span class="line">model.add(Conv2D(64, kernel_size&#x3D;(3, 3), activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(MaxPooling2D(pool_size&#x3D;(2, 2)))</span><br><span class="line">model.add(Conv2D(128, kernel_size&#x3D;(3, 3), activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(MaxPooling2D(pool_size&#x3D;(2, 2)))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(512, activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(Dense(1, activation&#x3D;&#39;sigmoid&#39;))</span><br><span class="line"></span><br><span class="line">model.compile(loss&#x3D;&#39;binary_crossentropy&#39;,</span><br><span class="line">              optimizer&#x3D;optimizers.RMSprop(),</span><br><span class="line">              metrics&#x3D;[&#39;accuracy&#39;])</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p>模型架构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Layer (type) Output Shape Param #   </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">conv2d_1 (Conv2D) (None, 148, 148, 16) 448       </span><br><span class="line">_________________________________________________________________</span><br><span class="line">max_pooling2d_1 (MaxPooling2 (None, 74, 74, 16) 0         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">conv2d_2 (Conv2D) (None, 72, 72, 64) 9280      </span><br><span class="line">_________________________________________________________________</span><br><span class="line">max_pooling2d_2 (MaxPooling2 (None, 36, 36, 64) 0         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">conv2d_3 (Conv2D) (None, 34, 34, 128) 73856     </span><br><span class="line">_________________________________________________________________</span><br><span class="line">max_pooling2d_3 (MaxPooling2 (None, 17, 17, 128) 0         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">flatten_1 (Flatten) (None, 36992) 0         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_1 (Dense) (None, 512) 18940416  </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_2 (Dense) (None, 1) 513       </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Total params: 19,024,513</span><br><span class="line">Trainable params: 19,024,513</span><br><span class="line">Non-trainable params: 0</span><br></pre></td></tr></table></figure>

<p>我们设置<code>batch_size=30</code>，总共有3000张图片，也就是一个epoch需要100次迭代。我们训练30个epoch，然后验证模型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">batch_size &#x3D; 30</span><br><span class="line">num_classes &#x3D; 2</span><br><span class="line">epochs &#x3D; 30</span><br><span class="line">history &#x3D; model.fit(x&#x3D;train_imgs_scaled, y&#x3D;train_labels_enc,</span><br><span class="line">                    validation_data&#x3D;(validation_imgs_scaled, validation_labels_enc),</span><br><span class="line">                    batch_size&#x3D;batch_size,</span><br><span class="line">                    epochs&#x3D;epochs,</span><br><span class="line">                    verbose&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>训练过程的输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Train on 3000 samples, validate on 1000 samples</span><br><span class="line">Epoch 1&#x2F;30</span><br><span class="line">3000&#x2F;3000 - 10s - loss: 0.7583 - acc: 0.5627 - val_loss: 0.7182 - val_acc: 0.5520</span><br><span class="line">Epoch 2&#x2F;30</span><br><span class="line">3000&#x2F;3000 - 8s - loss: 0.6343 - acc: 0.6533 - val_loss: 0.5891 - val_acc: 0.7190</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Epoch 29&#x2F;30</span><br><span class="line">3000&#x2F;3000 - 8s - loss: 0.0314 - acc: 0.9950 - val_loss: 2.7014 - val_acc: 0.7140</span><br><span class="line">Epoch 30&#x2F;30</span><br><span class="line">3000&#x2F;3000 - 8s - loss: 0.0147 - acc: 0.9967 - val_loss: 2.4963 - val_acc: 0.7220</span><br></pre></td></tr></table></figure>
<p>训练集都接近100%准确率了，但是验证集准确率还只有72%。模型可能存在过拟合。可以使用如下的代码画出训练和验证过程的loss下降和准确率变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">f, (ax1, ax2) &#x3D; plt.subplots(1, 2, figsize&#x3D;(12, 4))</span><br><span class="line">t &#x3D; f.suptitle(&#39;Basic CNN Performance&#39;, fontsize&#x3D;12)</span><br><span class="line">f.subplots_adjust(top&#x3D;0.85, wspace&#x3D;0.3)</span><br><span class="line"></span><br><span class="line">epoch_list &#x3D; list(range(1,31))</span><br><span class="line">ax1.plot(epoch_list, history.history[&#39;acc&#39;], label&#x3D;&#39;Train Accuracy&#39;)</span><br><span class="line">ax1.plot(epoch_list, history.history[&#39;val_acc&#39;], label&#x3D;&#39;Validation Accuracy&#39;)</span><br><span class="line">ax1.set_xticks(np.arange(0, 31, 5))</span><br><span class="line">ax1.set_ylabel(&#39;Accuracy Value&#39;)</span><br><span class="line">ax1.set_xlabel(&#39;Epoch&#39;)</span><br><span class="line">ax1.set_title(&#39;Accuracy&#39;)</span><br><span class="line">l1 &#x3D; ax1.legend(loc&#x3D;&quot;best&quot;)</span><br><span class="line"></span><br><span class="line">ax2.plot(epoch_list, history.history[&#39;loss&#39;], label&#x3D;&#39;Train Loss&#39;)</span><br><span class="line">ax2.plot(epoch_list, history.history[&#39;val_loss&#39;], label&#x3D;&#39;Validation Loss&#39;)</span><br><span class="line">ax2.set_xticks(np.arange(0, 31, 5))</span><br><span class="line">ax2.set_ylabel(&#39;Loss Value&#39;)</span><br><span class="line">ax2.set_xlabel(&#39;Epoch&#39;)</span><br><span class="line">ax2.set_title(&#39;Loss&#39;)</span><br><span class="line">l2 &#x3D; ax2.legend(loc&#x3D;&quot;best&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/blog/transfer_learning_pratice_1.png" alt=""></p>
<p>上图左可以看到，3个epoch之后就开始过拟合了，训练准确率一直上升，但是验证准确率保持不变了。</p>
<h3 id="2-1-简单的优化模型"><a href="#2-1-简单的优化模型" class="headerlink" title="2.1 简单的优化模型"></a>2.1 简单的优化模型</h3><p>上面的CNN是个基本的架构，接下来我们做一些优化策略，网络架构上加入正则化，使用一定概率的dropout。只修改网络结构部分，其他训练代码不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">model &#x3D; Sequential()</span><br><span class="line">model.add(Conv2D(16, kernel_size&#x3D;(3, 3), activation&#x3D;&#39;relu&#39;, </span><br><span class="line">                 input_shape&#x3D;input_shape))</span><br><span class="line">model.add(MaxPooling2D(pool_size&#x3D;(2, 2)))</span><br><span class="line">model.add(Conv2D(64, kernel_size&#x3D;(3, 3), activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(MaxPooling2D(pool_size&#x3D;(2, 2)))</span><br><span class="line">model.add(Conv2D(128, kernel_size&#x3D;(3, 3), activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(MaxPooling2D(pool_size&#x3D;(2, 2)))</span><br><span class="line">model.add(Conv2D(128, kernel_size&#x3D;(3, 3), activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(MaxPooling2D(pool_size&#x3D;(2, 2)))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(512, activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(Dropout(0.3))</span><br><span class="line">model.add(Dense(512, activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(Dropout(0.3))</span><br><span class="line">model.add(Dense(1, activation&#x3D;&#39;sigmoid&#39;))</span><br><span class="line"></span><br><span class="line">model.compile(loss&#x3D;&#39;binary_crossentropy&#39;,</span><br><span class="line">              optimizer&#x3D;optimizers.RMSprop(),</span><br><span class="line">              metrics&#x3D;[&#39;accuracy&#39;])          </span><br><span class="line">history &#x3D; model.fit(x&#x3D;train_imgs_scaled, y&#x3D;train_labels_enc,</span><br><span class="line">                    validation_data&#x3D;(validation_imgs_scaled, validation_labels_enc),</span><br><span class="line">                    batch_size&#x3D;batch_size,</span><br><span class="line">                    epochs&#x3D;epochs,</span><br><span class="line">                    verbose&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>使用上面的画图代码，画出训练曲线。</p>
<p><img src="/images/blog/transfer_learning_pratice_2.png" alt=""></p>
<p>有所改善，但是效果不明显。依然是过拟合，究其原因，数据量太少，可以使用部分的数据集增强策略增加数据多样性。</p>
<h3 id="2-2-使用数据增强策略"><a href="#2-2-使用数据增强策略" class="headerlink" title="2.2 使用数据增强策略"></a>2.2 使用数据增强策略</h3><p>keras的<code>ImageDataGenerator</code>自带了一些数据增强方法，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_datagen &#x3D; ImageDataGenerator(rescale&#x3D;1.&#x2F;255, zoom_range&#x3D;0.3, rotation_range&#x3D;50,</span><br><span class="line">                                   width_shift_range&#x3D;0.2, height_shift_range&#x3D;0.2, shear_range&#x3D;0.2, </span><br><span class="line">                                   horizontal_flip&#x3D;True, fill_mode&#x3D;&#39;nearest&#39;)</span><br><span class="line">val_datagen &#x3D; ImageDataGenerator(rescale&#x3D;1.&#x2F;255)</span><br></pre></td></tr></table></figure>
<p>当然，我们还可以使用 <a href="https://github.com/albu/albumentations" target="_blank" rel="noopener">Albumentations</a>来做更多的增强策略。我们先来看看<code>ImageDataGenerator</code>增强之后的图片效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mg_id &#x3D; 2595</span><br><span class="line">cat_generator &#x3D; train_datagen.flow(train_imgs[img_id:img_id+1], train_labels[img_id:img_id+1],</span><br><span class="line">                                   batch_size&#x3D;1)</span><br><span class="line">cat &#x3D; [next(cat_generator) for i in range(0,5)]</span><br><span class="line">fig, ax &#x3D; plt.subplots(1,5, figsize&#x3D;(16, 6))</span><br><span class="line">print(&#39;Labels:&#39;, [item[1][0] for item in cat])</span><br><span class="line">l &#x3D; [ax[i].imshow(cat[i][0][0]) for i in range(0,5)]</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/transfer_learning_pratice_3.png" alt=""></p>
<p>再次使用上面的基准模型(加了dropout层的)，此次我们将学习率稍微改小点，将默认的<code>1e-3</code>改为<code>1e-4</code>，防止模型过拟合，此时的数据量增多了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model.compile(loss&#x3D;&#39;binary_crossentropy&#39;,</span><br><span class="line">              optimizer&#x3D;optimizers.RMSprop(lr&#x3D;1e-4),</span><br><span class="line">              metrics&#x3D;[&#39;accuracy&#39;])        </span><br><span class="line">history &#x3D; model.fit_generator(train_generator, steps_per_epoch&#x3D;100, epochs&#x3D;100,</span><br><span class="line">                              validation_data&#x3D;val_generator, validation_steps&#x3D;50, </span><br><span class="line">                              verbose&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>打印训练曲线<br><img src="/images/blog/transfer_learning_pratice_4.png" alt=""></p>
<p>模型的准确率提升到<strong>82%</strong>，而且已经不再过拟合了。</p>
<h2 id="3-使用其他模型做迁移学习"><a href="#3-使用其他模型做迁移学习" class="headerlink" title="3 使用其他模型做迁移学习"></a>3 使用其他模型做迁移学习</h2><h3 id="3-1-VGG-16模型"><a href="#3-1-VGG-16模型" class="headerlink" title="3.1 VGG-16模型"></a>3.1 VGG-16模型</h3><p>分类模型，我们选用VGG16为例。首先，我们需要理解VGG16的模型架构，如下</p>
<p><img src="/images/blog/transfer_learning_pratice_5.png" alt=""></p>
<p>13个$3\times 3$的卷积，5个maxpooling缩减了网络输入尺寸。在两个全连接层之前的输出是4096个神经元，全连接都是1000个神经元(代表了1000个分类)。由于我们要做的是做猫狗分类，最后三层是不需要的。我们更关心前5个blocks(下图)，我们可以将VGG模型看做一个特征抽取器。下图是VGG模型的三种用法</p>
<p><img src="/images/blog/transfer_learning_pratice_6.png" alt=""></p>
<ul>
<li>如果我们只是作为特征抽取器，则按照图中中间的示例，冻结所有的blocks(5个)，在训练过程中，这些blocks中的所有参数都不会更新。</li>
<li>如果我们做fine-tuning，可以考虑按照图右冻结前3个blocks，更新后面两个blocks(4和5)的参数（每个训练epoch过程都会）。</li>
</ul>
<h3 id="3-2-将预训练模型作为特征抽取器"><a href="#3-2-将预训练模型作为特征抽取器" class="headerlink" title="3.2 将预训练模型作为特征抽取器"></a>3.2 将预训练模型作为特征抽取器</h3><p>3.1节中最后一张图的中间的架构，冻结所有blocks层的参数的用法。下面是对应的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from keras.applications import vgg16</span><br><span class="line">from keras.models import Model</span><br><span class="line">import keras</span><br><span class="line"></span><br><span class="line">vgg &#x3D; vgg16.VGG16(include_top&#x3D;False, weights&#x3D;&#39;imagenet&#39;, </span><br><span class="line">                                     input_shape&#x3D;input_shape)</span><br><span class="line"></span><br><span class="line">output &#x3D; vgg.layers[-1].output</span><br><span class="line">output &#x3D; keras.layers.Flatten()(output)</span><br><span class="line">vgg_model &#x3D; Model(vgg.input, output)</span><br><span class="line"></span><br><span class="line">vgg_model.trainable &#x3D; False</span><br><span class="line">for layer in vgg_model.layers:</span><br><span class="line">    layer.trainable &#x3D; False</span><br><span class="line">    </span><br><span class="line">import pandas as pd</span><br><span class="line">pd.set_option(&#39;max_colwidth&#39;, -1)</span><br><span class="line">layers &#x3D; [(layer, layer.name, layer.trainable) for layer in vgg_model.layers]</span><br><span class="line">pd.DataFrame(layers, columns&#x3D;[&#39;Layer Type&#39;, &#39;Layer Name&#39;, &#39;Layer Trainable&#39;])</span><br></pre></td></tr></table></figure>
<p><img src="/images/blog/transfer_learning_pratice_7.png" alt=""></p>
<p>此处，将VGG模型看做SURF或者HOG特征之类的东西就可以，使用过程不更新参数，直接输入图片，预测得到特征。用法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bottleneck_feature_example &#x3D; vgg.predict(train_imgs_scaled[0:1])</span><br><span class="line">print(bottleneck_feature_example.shape)</span><br><span class="line">plt.imshow(bottleneck_feature_example[0][:,:,0])</span><br></pre></td></tr></table></figure>
<p><img src="/images/blog/transfer_learning_pratice_8.png" alt=""></p>
<p>从训练数据和验证数据中使用VGG16抽取特征如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def get_bottleneck_features(model, input_imgs):</span><br><span class="line">    features &#x3D; model.predict(input_imgs, verbose&#x3D;0)</span><br><span class="line">    return features</span><br><span class="line"></span><br><span class="line">train_features_vgg &#x3D; get_bottleneck_features(vgg_model, train_imgs_scaled)</span><br><span class="line">validation_features_vgg &#x3D; get_bottleneck_features(vgg_model, validation_imgs_scaled)</span><br><span class="line">print(&#39;Train Bottleneck Features:&#39;, train_features_vgg.shape, </span><br><span class="line">      &#39;\tValidation Bottleneck Features:&#39;, validation_features_vgg.shape)</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Bottleneck Features: (3000, 8192)  </span><br><span class="line">Validation Bottleneck Features: (1000, 8192)</span><br></pre></td></tr></table></figure>
<p>接下来，我们可以以VGG作为特征抽取器重新构建一个训练模型。其实，在抽取特征之后直接接一个SVM或者KNN分类器也是一样的。下面以keras代码，重新构建CNN模型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, InputLayer</span><br><span class="line">from keras.models import Sequential</span><br><span class="line">from keras import optimizers</span><br><span class="line"># 此时的vgg_model 已经设置了trainable&#x3D;False</span><br><span class="line">input_shape &#x3D; vgg_model.output_shape[1]</span><br><span class="line"></span><br><span class="line">model &#x3D; Sequential()</span><br><span class="line">model.add(InputLayer(input_shape&#x3D;(input_shape,)))</span><br><span class="line">model.add(Dense(512, activation&#x3D;&#39;relu&#39;, input_dim&#x3D;input_shape))</span><br><span class="line">model.add(Dropout(0.3))</span><br><span class="line">model.add(Dense(512, activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(Dropout(0.3))</span><br><span class="line">model.add(Dense(1, activation&#x3D;&#39;sigmoid&#39;))</span><br><span class="line"></span><br><span class="line">model.compile(loss&#x3D;&#39;binary_crossentropy&#39;,</span><br><span class="line">              optimizer&#x3D;optimizers.RMSprop(lr&#x3D;1e-4),</span><br><span class="line">              metrics&#x3D;[&#39;accuracy&#39;])</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p>网络结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_________________________________________________________________</span><br><span class="line">Layer (type) Output Shape Param #   </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">input_2 (InputLayer) (None, 8192) 0         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_1 (Dense) (None, 512) 4194816   </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dropout_1 (Dropout) (None, 512) 0         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_2 (Dense) (None, 512) 262656    </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dropout_2 (Dropout) (None, 512) 0         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_3 (Dense) (None, 1) 513       </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Total params: 4,457,985</span><br><span class="line">Trainable params: 4,457,985</span><br><span class="line">Non-trainable params: 0</span><br></pre></td></tr></table></figure>
<p><strong>注意，此时的训练代码中输入数据不再是图片，而是VGG抽取的特征了</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history &#x3D; model.fit(x&#x3D;train_features_vgg, y&#x3D;train_labels_enc,</span><br><span class="line">                    validation_data&#x3D;(validation_features_vgg, validation_labels_enc),</span><br><span class="line">                    batch_size&#x3D;batch_size,</span><br><span class="line">                    epochs&#x3D;epochs,</span><br><span class="line">                    verbose&#x3D;1)</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/transfer_learning_pratice_9.png" alt=""></p>
<p>验证准确率提升到<strong>88%</strong>，虽然看起来依然过拟合了。</p>
<h3 id="3-3-使用数据增强-VGG作为特征抽取器"><a href="#3-3-使用数据增强-VGG作为特征抽取器" class="headerlink" title="3.3 使用数据增强+VGG作为特征抽取器"></a>3.3 使用数据增强+VGG作为特征抽取器</h3><p>由于我们使用data generator，此处不再用VGG作为特征抽取器.此部分与上面的区别在于，上面的VGG模型不是网络的一部分，属于数据处理部分，用vgg将处理图片(特征抽取)之后的数据传入了新的小网络。而当前是将VGG作为网络的一部分，与新的网络层，构建了一个新模型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">train_datagen &#x3D; ImageDataGenerator(rescale&#x3D;1.&#x2F;255, zoom_range&#x3D;0.3, rotation_range&#x3D;50,</span><br><span class="line">                                   width_shift_range&#x3D;0.2, height_shift_range&#x3D;0.2, shear_range&#x3D;0.2, </span><br><span class="line">                                   horizontal_flip&#x3D;True, fill_mode&#x3D;&#39;nearest&#39;)</span><br><span class="line"></span><br><span class="line">val_datagen &#x3D; ImageDataGenerator(rescale&#x3D;1.&#x2F;255)</span><br><span class="line">train_generator &#x3D; train_datagen.flow(train_imgs, train_labels_enc, batch_size&#x3D;30)</span><br><span class="line">val_generator &#x3D; val_datagen.flow(validation_imgs, validation_labels_enc, batch_size&#x3D;20)</span><br></pre></td></tr></table></figure>
<p>网络构建部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from keras.applications import vgg16</span><br><span class="line">from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, InputLayer</span><br><span class="line">from keras.models import Sequential</span><br><span class="line">from keras import optimizers</span><br><span class="line">from keras.models import Model</span><br><span class="line">import keras</span><br><span class="line"></span><br><span class="line">vgg &#x3D; vgg16.VGG16(include_top&#x3D;False, weights&#x3D;&#39;imagenet&#39;, </span><br><span class="line">                                     input_shape&#x3D;input_shape)</span><br><span class="line"></span><br><span class="line">output &#x3D; vgg.layers[-1].output</span><br><span class="line">output &#x3D; keras.layers.Flatten()(output)</span><br><span class="line">vgg_model &#x3D; Model(vgg.input, output)</span><br><span class="line"></span><br><span class="line">vgg_model.trainable &#x3D; False</span><br><span class="line">for layer in vgg_model.layers:</span><br><span class="line">    layer.trainable &#x3D; False</span><br><span class="line"># 下面是我们新加的网络层，将VGG放在前面</span><br><span class="line">model &#x3D; Sequential()</span><br><span class="line">model.add(vgg_model)</span><br><span class="line">model.add(Dense(512, activation&#x3D;&#39;relu&#39;, input_dim&#x3D;input_shape))</span><br><span class="line">model.add(Dropout(0.3))</span><br><span class="line">model.add(Dense(512, activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(Dropout(0.3))</span><br><span class="line">model.add(Dense(1, activation&#x3D;&#39;sigmoid&#39;))</span><br><span class="line"># 学习率变小了</span><br><span class="line">model.compile(loss&#x3D;&#39;binary_crossentropy&#39;,</span><br><span class="line">              optimizer&#x3D;optimizers.RMSprop(lr&#x3D;2e-5),</span><br><span class="line">              metrics&#x3D;[&#39;accuracy&#39;])</span><br><span class="line">              </span><br><span class="line">history &#x3D; model.fit_generator(train_generator, steps_per_epoch&#x3D;100, epochs&#x3D;100,</span><br><span class="line">                              validation_data&#x3D;val_generator, validation_steps&#x3D;50, </span><br><span class="line">                              verbose&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>此时的学习曲线，如下</p>
<p><img src="/images/blog/transfer_learning_pratice_10.png" alt=""></p>
<p>此时的验证准确率提升到了90%，而且没有过拟合。</p>
<h3 id="3-5-fine-tuning-预训练的VGG模型-数据增强"><a href="#3-5-fine-tuning-预训练的VGG模型-数据增强" class="headerlink" title="3.5 fine-tuning 预训练的VGG模型+数据增强"></a>3.5 fine-tuning 预训练的VGG模型+数据增强</h3><p>此部分，可以参考3.1节部分VGG示意图的最右边那张图，此时vgg模型中某些blocks的参数也在训练过程中得到更新。如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vgg_model.trainable &#x3D; True</span><br><span class="line"></span><br><span class="line">set_trainable &#x3D; False</span><br><span class="line">for layer in vgg_model.layers:</span><br><span class="line">    if layer.name in [&#39;block5_conv1&#39;, &#39;block4_conv1&#39;]:</span><br><span class="line">        set_trainable &#x3D; True</span><br><span class="line">    if set_trainable:</span><br><span class="line">        layer.trainable &#x3D; True</span><br><span class="line">    else:</span><br><span class="line">        layer.trainable &#x3D; False</span><br><span class="line">        </span><br><span class="line">layers &#x3D; [(layer, layer.name, layer.trainable) for layer in vgg_model.layers]</span><br><span class="line">pd.DataFrame(layers, columns&#x3D;[&#39;Layer Type&#39;, &#39;Layer Name&#39;, &#39;Layer Trainable&#39;])</span><br></pre></td></tr></table></figure>
<p><img src="/images/blog/transfer_learning_pratice_11.png" alt=""></p>
<p>可以看到<code>block4</code>和<code>block5</code>已经变成可以训练了。此时再次减小学习率，同时使用了增强了的数据处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">train_datagen &#x3D; ImageDataGenerator(rescale&#x3D;1.&#x2F;255, zoom_range&#x3D;0.3, rotation_range&#x3D;50,</span><br><span class="line">                                   width_shift_range&#x3D;0.2, height_shift_range&#x3D;0.2, shear_range&#x3D;0.2, </span><br><span class="line">                                   horizontal_flip&#x3D;True, fill_mode&#x3D;&#39;nearest&#39;)</span><br><span class="line">val_datagen &#x3D; ImageDataGenerator(rescale&#x3D;1.&#x2F;255)</span><br><span class="line">train_generator &#x3D; train_datagen.flow(train_imgs, train_labels_enc, batch_size&#x3D;30)</span><br><span class="line">val_generator &#x3D; val_datagen.flow(validation_imgs, validation_labels_enc, batch_size&#x3D;20)</span><br><span class="line"></span><br><span class="line">from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, InputLayer</span><br><span class="line">from keras.models import Sequential</span><br><span class="line">from keras import optimizers</span><br><span class="line"></span><br><span class="line">model &#x3D; Sequential()</span><br><span class="line">model.add(vgg_model)</span><br><span class="line">model.add(Dense(512, activation&#x3D;&#39;relu&#39;, input_dim&#x3D;input_shape))</span><br><span class="line">model.add(Dropout(0.3))</span><br><span class="line">model.add(Dense(512, activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(Dropout(0.3))</span><br><span class="line">model.add(Dense(1, activation&#x3D;&#39;sigmoid&#39;))</span><br><span class="line"></span><br><span class="line">model.compile(loss&#x3D;&#39;binary_crossentropy&#39;,</span><br><span class="line">              optimizer&#x3D;optimizers.RMSprop(lr&#x3D;1e-5),</span><br><span class="line">              metrics&#x3D;[&#39;accuracy&#39;])</span><br><span class="line">              </span><br><span class="line">history &#x3D; model.fit_generator(train_generator, steps_per_epoch&#x3D;100, epochs&#x3D;100,</span><br><span class="line">                              validation_data&#x3D;val_generator, validation_steps&#x3D;50, </span><br><span class="line">                              verbose&#x3D;1)</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/transfer_learning_pratice_12.png" alt=""></p>
<p>可以看到，验证准确率已经提升到了<strong>96%</strong>，与基准模型相比，提升了24%。</p>
<h2 id="4-测试模型"><a href="#4-测试模型" class="headerlink" title="4 测试模型"></a>4 测试模型</h2><p>接下来在测试集上测试上面的5种模型</p>
<ol>
<li>基准CNN模型</li>
<li>使用了数据增强的基准CNN模型</li>
<li>迁移学习：使用VGG16作为特征抽取器【VGG只用在数据处理上】</li>
<li>迁移学习：使用VGG作为模型的一部分，并且使用了数据增强策略</li>
<li>迁移学习：对VGG模型微调，让其<code>block4</code>和<code>block5</code>参数可更新</li>
</ol>
<p>测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IMG_DIM &#x3D; (150, 150)</span><br><span class="line"></span><br><span class="line">test_files &#x3D; glob.glob(&#39;test_data&#x2F;*&#39;)</span><br><span class="line">test_imgs &#x3D; [img_to_array(load_img(img, target_size&#x3D;IMG_DIM)) for img in test_files]</span><br><span class="line">test_imgs &#x3D; np.array(test_imgs)</span><br><span class="line">test_labels &#x3D; [fn.split(&#39;&#x2F;&#39;)[1].split(&#39;.&#39;)[0].strip() for fn in test_files]</span><br><span class="line"></span><br><span class="line">test_imgs_scaled &#x3D; test_imgs.astype(&#39;float32&#39;)</span><br><span class="line">test_imgs_scaled &#x2F;&#x3D; 255</span><br><span class="line">test_labels_enc &#x3D; class2num_label_transformer(test_labels)</span><br><span class="line"></span><br><span class="line">print(&#39;Test dataset shape:&#39;, test_imgs.shape)</span><br><span class="line">print(test_labels[0:5], test_labels_enc[0:5])</span><br></pre></td></tr></table></figure>
<p>测试基准模型的代码如下（其他模型类似）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predictions &#x3D; basic_cnn.predict_classes(test_imgs_scaled, verbose&#x3D;0)</span><br><span class="line">predictions &#x3D; num2class_label_transformer(predictions)</span><br><span class="line">meu.display_model_performance_metrics(true_labels&#x3D;test_labels, predicted_labels&#x3D;predictions, </span><br><span class="line">                                      classes&#x3D;list(set(test_labels)))</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog/transfer_learning_pratice_13.png" alt=""></p>

    </div>
    <p class="post-meta">
        <span class="post-cat">分类：
            <a class="cat-link" href="/categories/blog/">blog</a>
        </span>
        <span class="post-tags">
            标签：
            
        </span>
    </p>
</article>
<!-- 分享按钮 -->

  <div class="article-share clearfix text-center">
    <div class="share-area">
      <span class="share-txt">分享到：</span>
      <a href="javascript: window.open('http://service.weibo.com/share/share.php?url=' + encodeURIComponent(location.href) + '&title=' + document.title + '&language=zh_cn');" class="share-icon weibo"></a>
      <a href="javascript: alert('请复制链接到微信并发送');" class="share-icon wechat"></a>
      <a href="javascript: window.open('http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + encodeURIComponent(location.href) + '&title=' + document.title);" class="share-icon qqzone"></a>
      <a href="javascript: window.open('http://connect.qq.com/widget/shareqq/index.html?url=' + encodeURIComponent(location.href) + '&desc=Jelon个人博客&title=' + document.title + '&callback=' + encodeURIComponent(location.href));" class="share-icon qq"></a>
      <a href="javascript: window.open('http://shuo.douban.com/!service/share?href=' + encodeURIComponent(location.href) + '&name=' + document.title + '&text=' + document.title);" class="share-icon douban"></a>
    </div>
  </div>


<!-- 上一篇/下一篇 -->

<div class="article-nav clearfix">
    
    <span class="prev fl">
        上一篇<br >
        <a href="/2019/12/23/2018-08-10-TTS_MSD_HMM/">
            
                语音合成：MSD-HMM多空间概率分布HMM
            
        </a>
    </span>
    

    
    <span class="next fr">
        下一篇<br >
        <a href="/2019/12/23/2018-05-11-LHY_transferlearning/">
            
                李宏毅深度学习：迁移学习
            
        </a>
    </span>
    
</div>

<!-- 文章评论 -->

  
<script src="/js/comment.js"></script>

  <div id="comments" class="comment">
    <!--
    <div class="sign-bar">
      GitHub 已登录!
      <span class="sign-link">登出</span>
    </div>
    <section class="box">
      <div class="com-avatar"><img src="/img/jelon.jpg" alt="avatar"></div>
      <div class="com-text">
        <div class="main">
          <textarea class="text-area-edited show" placeholder="欢迎评论！"></textarea>
          <div class="text-area-preview"></div>
        </div>
        <div class="switch">
          <div class="switch-item on">编辑</div>
          <div class="switch-item">预览</div>
        </div>
        <div class="button">提交</div>
      </div>
    </section>
    <section class="tips">注：评论支持 markdown 语法！</section>
    <section class="list-wrap">
      <ul class="list">
        <li>
          <div class="user-avatar">
            <a href="/">
              <img src="/img/jelon.jpg" alt="user-avatar">
            </a>
          </div>
          <div class="user-comment">
            <div class="user-comment-header">
              <span class="post-name">张德龙</span>
              <span class="post-time">2017年12月12日</span>
              <span class="like liked">已赞</span>
              <span class="like-num">2</span>
            </div>
            <div class="user-comment-body">333333</div>
          </div>
        </li>
        <li>
          <div class="user-avatar">
            <a href="/">
              <img src="/img/jelon.jpg" alt="user-avatar">
            </a>
          </div>
          <div class="user-comment">
            <div class="user-comment-header">
              <span class="post-name">刘德华</span>
              <span class="post-time">2017年12月12日</span>
              <span class="like">点赞</span>
              <span class="like-num">2</span>
            </div>
            <div class="user-comment-body">vvvvv</div>
          </div>
        </li>
      </ul>
      <div class="page-nav">
        <a href="javascript: void(0);" class="item">1</a>
        <a href="javascript: void(0);" class="item">2</a>
        <a href="javascript: void(0);" class="item current">3</a>
      </div>
    </section>
    -->
  </div>
  <script>
  JELON.Comment({
    container: 'comments',
    label: '2018-06-02-transfer-learning-pratice' || '2019/12/23/2018-06-02-transfer-learning-pratice/',
    owner: 'your_github_id',
    repo: 'your_blog_comments',
    clientId: 'your_client_id',
    clientSecret: 'your_client_secret'
  });
  </script>


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/blog/">blog</a>
        <span class="badge">(94)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="https://jelon.top" target="_blank" title="Jelon个人前端小站">前端博客小站</a>
        </li>
    
        <li>
            <a href="https://www.baidu.com" target="_blank" title="百度搜索">百度</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->

<script src="/js/main.js"></script>

</body>
</html>